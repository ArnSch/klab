#!/usr/bin/env node
const xml2json = require("xml2json");

const fs = require("fs");
const _ = require("lodash");
const jsondiffpatch = require("jsondiffpatch").create({
   textDiff: {
        // default 60, minimum string length (left and right sides) to use text diff algorythm: google-diff-match-patch
        minLength: 10
    }
});
const clc = require('cli-color');
var clear = require("cli-clear");
const crypto = require('crypto');
const hash = string => {
  var md5sum = crypto.createHash('md5');
  md5sum.update(string);
  var d = md5sum.digest('hex');
  return d;
}

const { formatStep } = require("./../lib/formatter.js");

var stdin = process.stdin;
stdin.setRawMode( true );
stdin.resume();
stdin.setEncoding( 'utf8' );
const tw = process.stdout.columns; // total width

const jsonString = fs.readFileSync("./debug.json").toString();
const json = JSON.parse(jsonString);

const getFileExcerpt = (path, from, to) => fs.readFileSync(path).toString().split("\n").slice(from - 1, to).filter(l => l != "").join("\n");

const source_path = "/Users/mhhf/dh/verified-smart-contracts/dappsys/exponent-naive/out/ExponentNaive.sol.json";
const contract_name = "exp";
const src_filepath = "/Users/mhhf/dh/verified-smart-contracts/dappsys/exponent-naive/src/ExponentNaive.sol"; // TODO - get rid of this
const contract_search_regex = new RegExp("\\:" + contract_name);

const source_json = JSON.parse(fs.readFileSync(source_path));

const contract_location = Object.keys(source_json.contracts).find(s => contract_search_regex.test(s));

const bin_string = source_json.contracts[contract_location]["bin-runtime"];
const srcmap = source_json.contracts[contract_location]["srcmap-runtime"];

var code_arr = []
for(let i=0; i<bin_string.length; i+=2) {
  code_arr.push(parseInt(bin_string.slice(i, i+2), 16));
}
var pc_to_inst_map = [];
let pc=0;
let inst_c = 1;
while(pc < code_arr.length) {
  if(code_arr[pc] >= 96 && code_arr[pc] <= 127) {
    let size = code_arr[pc] - 96;
    for(let i = 0; i <= size; i++) {
      pc_to_inst_map.push(inst_c);
    }
    pc += size;
  } else {
    pc_to_inst_map.push(inst_c);
  }
  pc++;
  inst_c++;
}
// pc_to_inst_map.forEach((e,i) => {
// console.log(i,e);
// })

var last = [0, 0, 0, 0];
const srcmapArr = srcmap
  .split(";")
  .map(e => {
    if(e === "") return last
    let tmp = e.split(":")
      .map(o => parseInt(o))
      .forEach((o, i) => {
        if(typeof o === "number" && o > 0) last[i] = o;
      });
    return last.slice();
  })
  // .map(e => e.split(":").map(o => parseInt(o)))
var source = fs.readFileSync(src_filepath).toString();

const getCodeStringFromPc = pc => {
  let hide_color = 244;
  let show_color = 255;
  // console.log("pc", pc, "inst", pc_to_inst_map[pc], "srcmap", srcmapArr[pc_to_inst_map[pc]]);
  var cpos = srcmapArr[pc_to_inst_map[pc]];
  let hide = str => clc.xterm(hide_color)(str.split("\n").join("\n"))
  let show = str => clc.xterm(show_color)(str.split("\n").join("\n"))
  var str = (hide(source.slice(0, cpos[0])) + show(source.slice(cpos[0], cpos[0]+cpos[1])) + hide(source.slice(cpos[0]+cpos[1])));
  str = str.split("\n").map(s => "  " + s + " ".repeat(tw - 2 - clc.getStrippedLength(s))).join("\n");
  // str = clc.bgXterm(236)(str);
  return str;
}







const omits = [
  "generatedTop.ethereum.evm.txExecState.program",
  "generatedTop.ethereum.evm.txExecState.programBytes",
  "generatedTop.ethereum.evm.callStack"
];




var step_position = 0;


// build Nodes
const V = json.nodes;
Object.keys(V).forEach(key => {
  let term = _.omit(xml2json.toJson(V[key].term, {object: true}), omits).generatedTop;
  if(term.ethereum.evm.txExecState.wordStack.length > tw / 2) {
    term.ethereum.evm.txExecState.wordStack = term.ethereum.evm.txExecState.wordStack.split(":").join("\n");
  }
  V[key].term = term;
})


// build Edges
const E = {};
json.proofs[0].steps
.forEach(o => {
  if(!(o.from in E)) E[o.from] = [];
  E[o.from].push(o);
})

Object.keys(E).forEach(id => {
  E[id] = _.uniqBy(E[id], edge => edge.to);
})

// build Rules
const parseRule = ruleString => {
  const pos_regex = /Location\((\d+)\,\d+\,(\d+)\,\d+\)/;
  const src_regex = /Source\(Source\(([^\)]+)\)/;
  const location = ruleString.match(pos_regex);
  const filepath = ruleString.match(src_regex)[1];
  const from = location[1];
  const to = location[2];
  // let string = fs.readFileSync(filepath).toString();
  let string = clc.xterm(0)(`${filepath} ${from}-${to}\n     `) + getFileExcerpt(filepath, parseInt(from), parseInt(to)).trim();

  return {
    from,
    to,
    filepath,
    string
  };
}

const R = {};
Object.keys(json.rules)
.forEach(key => {
  R[key] = parseRule(json.rules[key]);
})

const initial = V[json.proofs[0].initialTerm].term;
const target  = V[json.proofs[0].targetTerm].term;

const initial_id = json.proofs[0].initialTerm;
const target_id  = json.proofs[0].targetTerm;


var crashHash = ("crash" in json.proofs[0]) && json.proofs[0].crash || "";
var crashRule = ("crash" in json.proofs[0]) && json.proofs[0].crash_rule || "";
var crashMsg  = ("crash" in json.proofs[0]) && json.proofs[0].exception || "";

var behaviour = "";
const genBehaviour = () => {
  let frontier = [{
    id: initial_id,
    path: "",
    leave: false
  }];
  let leaves = [];
  let terminate = false;
  let _visited = {
    [initial_id]: true
  };
  while (frontier.length > 0) {
    let next_frontier = [];
    frontier.forEach(e => {
      let next_steps = (E[e.id] || []);

      if(next_steps.length == 0) {
        e.leave = true;
        if( e.id === target_id ) e.path += clc.green(" âœ“");
        if( e.id === crashHash ) e.path += " ðŸ’¥";
        leaves.push(e);
        return null;
      }

      let next_frontier_steps = next_steps
        .map((step, i) => ({
          id: step.to,
          path: e.path + (next_steps.length > 1 ? i + "." : ""),
          leave: false
        }))
      next_frontier = next_frontier.concat(next_frontier_steps);
    });
    frontier = next_frontier;
  }
  behaviour = leaves
  .map(branch => branch.path)
  .sort()
  .join("\n")
}
genBehaviour();

var show_rule       = false;
var show_constraint = false;
var show_source     = false;

const help = (s_r, s_c, s_s, slice) => {
  let format_toggle = is => is ? clc.green("T") : clc.red("F");
  let h_ = [
    "0-5/n next choice",
    "N next branching point",
    "q quit",
    "p previous",
    "b show behaviour",
    `C toggle constraint (${format_toggle(s_c)})`,
    `R toggle rule (${format_toggle(s_r)})`,
    `S toggle source (${format_toggle(s_s)})`,
  ];
  let h_a = h_.slice(0, Math.floor(h_.length / 2));
  let h_b = h_.slice(Math.floor(h_.length / 2));
  let h_as = h_a.join("     ");
  let h_bs = h_b.join("     ");
  return [h_as, h_bs];
}

var draw = path => {
  let step = path[path.length - 1].step;
  let node_id = step.to;
  let isSuccess = node_id == target_id;
  let isCrash   = node_id == crashHash;

// help
  let help_strings = help(show_rule, show_constraint, show_source, 2);
  let help_display = help_strings.map(help_string => {
    let prefix = (tw - clc.getStrippedLength(help_string)) / 2
    console.log(" ".repeat(prefix) + help_string );
  })
  console.log("-".repeat(tw));

// behaviour
  let step_counter = path.length;
  let format_path = "root.";
  path.forEach(s => {
    if(s.type === "branch") format_path += s.branch + ".";
  });
  let format_step = "step: " + step_counter;
  let format_feedback = (isCrash ? " ðŸ’¥" : "") + (isSuccess ? clc.green(" âœ“") : "")
  let lhs = 'Behaviour: ' + format_path + format_feedback;
  let rhs = format_step;
  let nav = lhs + " ".repeat(tw - (lhs.length + rhs.length)) + rhs;
  console.log(nav + "\n");

// term
  let previous_node_id = null;
  let term;
  if(path.length > 1) {
    term = formatStep(V[node_id].term, V[step.from].term);
  } else {
    term = formatStep(V[node_id].term, {});
  }
  console.log(term);
// source code
  if(show_source) console.log(`\n${clc.bold(clc.underline("s")+"ource")}:\n` + getCodeStringFromPc(V[node_id].term.ethereum.evm.txExecState.pc));

// TODO - constraint
  let constraint;
  if(path.length > 1) {
    if(V[node_id].constraint !== V[step.from].constraint) {
      constraint = clc.yellow(V[node_id].constraint);
    } else {
      constraint = V[node_id].constraint;
    }
  } else {
    constraint = V[node_id].constraint;
  }
  constraint = constraint
    .split("\n")
    .join("")
    .split("#And")
    .map(s => "  " + s.replace(/ ==K true/g,"").trim())
    .join("\n")
  if(show_constraint) console.log(`\n${clc.bold(clc.underline("c")+"onstraint")}:\n  `+constraint.split("\n").join("\n  "));

// Rule
  if(show_rule) {
    let rule = step.rule in R && R[step.rule] || "";
    if(rule && rule.string) console.log(`\n${clc.bold(clc.underline("r") + "ule")}:\n  ` + rule.string);
  }

  let next_steps = E[node_id];
// Branching
  if(next_steps && next_steps.length > 1) {
    let branching_string = next_steps.map(({rule}, i) => i + ". " + R[rule].string).join("\n  ");
    console.log(`\n${clc.bold("branching")}: ${next_steps.length}\n  ${branching_string}`);
  }

// terminal
  if(isSuccess) {
    console.log(clc.green(` âœ“ Target Term Reached!`));
  }

// crash
  if(isCrash) {
    let ruleString = parseRule(crashRule).string;
    console.log(clc.red("\nCrash occurred during rule:\n") + ruleString);
    console.log("\n" + crashMsg.split("\n").slice(1).join("\n"));
  }
}

var path = [];
path.push({
  type: "step",
  step: {
    from: "",
    to: initial_id,
    rule: ""
  }
})

var state = "step"; // step, behaviour
const doStepState = (key) => {
  let id = path[path.length - 1].step.to;
  let steps = E[id];
  switch(key) {
    case "0":
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
      let index = parseInt(key) || 0;
      while(steps && steps.length === 1) {
        path.push({
          type: "step",
          step: steps[0]
        })
        steps = E[steps[0].to];
      }
      if(steps.length <= index) console.error("wrong index")
      path.push({
        type: "branch",
        branch: index,
        step: steps[index]
      })
      break;
    case "n":
      if(steps && steps.length === 1) {
        path.push({
          type: "step",
          step: steps[0]
        });
      }
      break;
    case "N":
      while(steps && steps.length === 1) {
        path.push({
          type: "step",
          step: steps[0]
        })
        steps = E[steps[0].to];
      }
      // if(path.length > 0) {
      //   let cstep = path[path.length - 1];
      //   current_step = v.steps.length - 1;
      // }
      break;
    case "p":
      if(path.length > 1) {
        path.pop();
      }
      break;
    case "P":
      if(path.length > 1) path.pop();
      while(path.length > 1 && E[path[path.length - 1].step.to].length == 1) {
        path.pop();
      }
      break;
    case "b":
      console.log(behaviour);
      break;
    case "r":
    case "R":
      show_rule = !show_rule;
      break;
    case "C":
    case "c":
      show_constraint = !show_constraint;
      break;
    case "S":
    case "s":
      show_source = !show_source;
      break;
    case "\u0003":
    case "q":
      process.exit();
      break;
    default:
      console.log("key: " + key);
  }

  draw(path);
}

clear();
draw(path);

stdin.on( 'data', function (key) {
  clear();

  if(state === "step") {
    doStepState(key)
  } else if(state === "behaviour") {
    state = "step";
  }
})
