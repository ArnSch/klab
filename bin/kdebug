#!/usr/bin/env node
// XXX  - steps seem to indicate the previous steps (or next one?)
//      - clean up path
//        I do need more cognitive abiity for this, lol
// TODO - path should never be empty
// TODO - can draw behaviour only one
// TODO - draw initial state by default
const xml2json = require("xml2json");

const fs = require("fs");
const _ = require("lodash");
const jsondiffpatch = require("jsondiffpatch").create({
   textDiff: {
        // default 60, minimum string length (left and right sides) to use text diff algorythm: google-diff-match-patch
        minLength: 10
    }
});
const clc = require('cli-color');
var clear = require("cli-clear");
const crypto = require('crypto');
const hash = string => {
  var md5sum = crypto.createHash('md5');
  md5sum.update(string);
  var d = md5sum.digest('hex');
  return d;
}

const { formatStep } = require("./../lib/formatter.js");

var stdin = process.stdin;
stdin.setRawMode( true );
stdin.resume();
stdin.setEncoding( 'utf8' );

const jsonString = fs.readFileSync("./debug.json").toString();
const json = JSON.parse(jsonString);

const getFileExcerpt = (path, from, to) => fs.readFileSync(path).toString().split("\n").slice(from - 1, to).filter(l => l != "").join("\n");

const help = (s_r, s_c) => [
  "0-5/n next choice",
  "N next branching point",
  "q quit",
  "p previous",
  "b show behaviour",
  `C toggle constraint (${s_c ? "T" : "F"})`,
  `R toggle rule (${s_r ? "T" : "F"})`
].join("     ");

// const bin_string = "606060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632e4c697f146044575b600080fd5b3415604e57600080fd5b606b60048080359060200190919080359060200190919050506081565b6040518082815260200191505060405180910390f35b6000600190505b600082111560a7576098838260ad565b90508180600190039250506088565b92915050565b60008082148060ca5750828283850292508281151560c757fe5b04145b151560d457600080fd5b929150505600a165627a7a72305820b5ac4b0841e89c109f1ce1a7648ad4054ecc8db0d1653b0b9dda992e425298730029";
// var code_arr = []
// for(let i=0; i<bin_string.length; i+=2) {
//   code_arr.push(parseInt(bin_string.slice(i, i+2), 16));
// }
// var pc_to_inst_map = [];
// let pc=0;
// let inst_c = 1;
// while(pc < code_arr.length) {
//   if(code_arr[pc] >= 96 && code_arr[pc] <= 127) {
//     let size = code_arr[pc] - 96;
//     for(let i = 0; i <= size; i++) {
//       pc_to_inst_map.push(inst_c);
//     }
//     pc += size;
//   } else {
//     pc_to_inst_map.push(inst_c);
//   }
//   pc++;
//   inst_c++;
// }
// // pc_to_inst_map.forEach((e,i) => {
// // console.log(i,e);
// // })
//
// const srcmap = "26:277:1:-;;;;;;;;;;;;;;;;;;;;;;;;166:135;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;216:6;236:1;232:5;;245:50;256:1;252;:5;245:50;;;275:9;279:1;282;275:3;:9::i;:::-;271:13;;259:3;;;;;;;;245:50;;;166:135;;;;:::o;45:116::-;97:6;128:1;123;:6;:30;;;;152:1;147;142;138;:5;134:9;;;133:15;;;;;;;;:20;123:30;115:39;;;;;;;;45:116;;;;:::o";
// const src_filepath = "/Users/mhhf/dh/verified-smart-contracts/dappsys/exponent-naive/src/ExponentNaive.sol";
// var last = [0,0,0,0];
// const srcmapArr = srcmap
//   .split(";")
//   .map(e => {
//     if(e === "") return last
//     let tmp = e.split(":")
//       .map(o => parseInt(o))
//       .forEach((o, i) => {
//         if(typeof o === "number" && o > 0) last[i] = o;
//       });
//     return last.slice();
//   })
//   // .map(e => e.split(":").map(o => parseInt(o)))
// var source = fs.readFileSync(src_filepath).toString();
//
// const getCodeStringFromPc = pc => {
//   // console.log("pc", pc, "inst", pc_to_inst_map[pc], "srcmap", srcmapArr[pc_to_inst_map[pc]]);
//   var cpos = srcmapArr[pc_to_inst_map[pc]];
//   var str = (source.slice(0, cpos[0]) + clc.blue(source.slice(cpos[0], cpos[0]+cpos[1])) + source.slice(cpos[0]+cpos[1]));
//   return str;
// }







const omits = [
  "generatedTop.ethereum.evm.txExecState.program",
  "generatedTop.ethereum.evm.txExecState.programBytes",
  "generatedTop.ethereum.evm.callStack"
];




var step_position = 0;


// build Nodes
const V = json.nodes;
Object.keys(V).forEach(key => {
  V[key].term = _.omit(xml2json.toJson(V[key].term, {object: true}), omits).generatedTop
})


// build Edges
const E = {};
json.proofs[0].steps
.forEach(o => {
  if(!(o.from in E)) E[o.from] = [];
  E[o.from].push(o);
})

Object.keys(E).forEach(id => {
  E[id] = _.uniqBy(E[id], edge => edge.to);
})

// build Rules
const parseRule = ruleString => {
  const pos_regex = /Location\((\d+)\,\d+\,(\d+)\,\d+\)/;
  const src_regex = /Source\(Source\(([^\)]+)\)/;
  const location = ruleString.match(pos_regex);
  const filepath = ruleString.match(src_regex)[1];
  const from = location[1];
  const to = location[2];
  // let string = fs.readFileSync(filepath).toString();
  let string = clc.xterm(0)(`${filepath} ${from}-${to}\n     `) + getFileExcerpt(filepath, parseInt(from), parseInt(to)).trim();

  return {
    from,
    to,
    filepath,
    string
  };
}

const R = {};
Object.keys(json.rules)
.forEach(key => {
  R[key] = parseRule(json.rules[key]);
})

const initial = V[json.proofs[0].initialTerm].term;
const target  = V[json.proofs[0].targetTerm].term;

const initial_id = json.proofs[0].initialTerm;
const target_id  = json.proofs[0].targetTerm;

// var visited   = {};
// TODO - refactor: no more behaviour object. but! filter branching edges
// const propagate = (o) => {
//   let id = o.id;
//   visited[id] = true;
//   let steps = [];
//   steps.push(id);
//   while((E[id] || []).length === 1) {
//     steps.push(E[id][0]);
//     visited[id] = true;
//     id = E[id][0].to;
//   }
//   o.steps = steps;
//   // TODO - rename cid to edge
//   o.children = (E[id] || [])
//   .filter(cid => !visited[cid.to])
//   .map(cid => {
//     o_ = ({
//       term: V[cid.to].term,
//       constraint: V[cid.to].constraint,
//       id: cid.to
//     })
//     // TODO - export to build rule
//     if(cid.rule) {
//       let {from, to, filepath} = R(cid.rule);
//       let ruleString = clc.xterm(0)(`${filepath} ${from}-${to}\n     `) + getFileExcerpt(filepath, parseInt(from), parseInt(to)).trim();
//       o_.rule = ruleString;
//     }
//     return propagate(o_);
//   });
//   return o;
// }
//
// // TODO - remove id from behaviour
// const behaviour = propagate({
//   term: initial,
//   id: initial_id
// });


// ----------------
//
//
//
// let c = hash(json[0].initialTerm);
// let history = [];

// Look for the reverse path:
// let endHash = hash(json[0].targetTerm);

// Object.keys(E)
// .forEach(id => {
//   let es = E[id];
//   if(es.indexOf(endHash) > -1) {
//     console.log("found: "+id);
//   }
// })




// drawStep(c);

// {
//   branch: number  current branch as choosen from last
//   total:  number  total last choices
// }
// let path = [];
// path.push({
//   type: 0,
//   total: 0
// })


// const getNode = path => {
//   if(path.length === 1) {
//     return behaviour;
//   } else {
//     return _.at(behaviour, 'children' + path.slice(1).map(s => `[${s.branch}]`).join('.children'))[0];
//   }
// }

// visited = {};
var crashHash = ("crash" in json.proofs[0]) && hash(json.proofs[0].crash) || "";
var crashRule = ("crash" in json.proofs[0]) && json.proofs[0].crash_rule || "";
var crashMsg  = ("crash" in json.proofs[0]) && json.proofs[0].exception || "";
// TODO - why does behaviour is ounly drawn once
// const drawBehaviour = () => {
//   const genBehaviourPath = (prefix, o) => {
//     visited[o.id] = true;
//     var children = (o.children || [])
//       .filter(edge => !visited[edge.id]);
//     if(children.length > 0) {
//       return children
//       .map((child, i) => genBehaviourPath(prefix + "." + i, child))
//       .reduce((a,e) => a.concat(e), []);
//     } else {
//       if(o.id == crashHash) return [prefix + " ðŸ’¥"]
//       if(o.steps[o.steps.length - 1] == target_id) return [prefix + clc.green(" âœ“")]
//       return [prefix];
//     }
//   }
//   console.log(genBehaviourPath("", behaviour).join("\n"));
// }
// var current_step = 0;
var current_element = initial_id;

// const draw = path => {
//   v = getNode(path);
//   let total_steps = v.steps.length;
//   // let cstep = path.length > 0 && path[path.length - 1].cstep || 0;
//   let id = v.steps[current_step].to;
//   let isCrash = id === crashHash;
//   let isSuccess = id === target_id;
//
//   let tw = process.stdout.columns; // total width
//   let prefix = (tw - help.length) / 2
//   console.log(" ".repeat(prefix) + help+"\n"+"-".repeat(tw));
//
//   let format_step = "step: " + current_step + "/" + total_steps + "  ";
//   let format_feedback = (isCrash ? " ðŸ’¥" : "") + (isSuccess ? clc.green(" âœ“") : "")
//   let format_path = 'root.' + path.slice(1).map(o => `${o.branch}`).join(".");
//
//   let lhs = 'Behaviour: ' + format_path + format_feedback;
//   let rhs = format_step;
//
//   let nav = lhs + " ".repeat(tw - (lhs.length + rhs.length)) + rhs;
//
//   console.log(nav + "\n");
//   drawStep(id);
//   // console.log(getCodeStringFromPc(V[id].generatedTop.ethereum.evm.txExecState.pc));
//   if(isCrash) {
//     // handle broken state
//     let {from, to, filepath} = parseRule(crashRule);
//     let ruleString = clc.xterm(0)(`${filepath} ${from}-${to}\n     `) + getFileExcerpt(filepath, parseInt(from), parseInt(to)).trim();
//     console.log(clc.red("\nCrash occurred during rule:\n") + ruleString);
//     console.log("\n" + crashMsg.split("\n").slice(1).join("\n"));
//   } else if(current_step >= total_steps - 1) {
//     console.log("\nBranching:\n  " + v.children.map((c,i) => i + ". " + c.rule).join("\n  "));
//   } else {
//     // TODO - display rule, which will be taken for the next step
//   }
// }

var show_rule = true;
var show_constraint = true;

var draw = path => {
  let step = path[path.length - 1].step;
  let node_id = step.to;
  let isSuccess = node_id == target_id;
  let isCrash   = node_id == crashHash;
  let tw = process.stdout.columns; // total width

// help
  let help_string = help(show_rule, show_constraint);
  let prefix = (tw - help_string.length) / 2
  console.log(" ".repeat(prefix) + help_string + "\n" + "-".repeat(tw));

// behaviour
  let step_counter = path.length;
  let format_path = "root.";
  path.forEach(s => {
    if(s.type === "branch") format_path += s.branch + ".";
  });
  let format_step = "step: " + step_counter;
  let format_feedback = (isCrash ? " ðŸ’¥" : "") + (isSuccess ? clc.green(" âœ“") : "")
  let lhs = 'Behaviour: ' + format_path + format_feedback;
  let rhs = format_step;
  let nav = lhs + " ".repeat(tw - (lhs.length + rhs.length)) + rhs;
  console.log(nav + "\n");

// term
  let previous_node_id = null;
  let term;
  if(path.length > 1) {
    term = formatStep(V[node_id].term, V[step.from].term);
  } else {
    term = formatStep(V[node_id].term, {});
  }
  console.log(term);

// TODO - constraint
  let constraint;
  if(path.length > 1) {
    if(V[node_id].constraint !== V[step.from].constraint) {
      constraint = clc.yellow(V[node_id].constraint);
    } else {
      constraint = V[node_id].constraint;
    }
  } else {
    constraint = V[node_id].constraint;
  }
  if(show_constraint) console.log("\nconstraint:\n  "+constraint.split("\n").join("\n  "));

// Rule
  if(show_rule) {
    let rule = step.rule in R && R[step.rule] || "";
    if(rule && rule.string) console.log(`rule:\n  ` + rule.string);
  }

  let next_steps = E[node_id];
// Branching
  if(next_steps && next_steps.length > 1) {
    let branching_string = next_steps.map(({rule}, i) => i + ". " + R[rule].string).join("\n  ");
    console.log(`\nbranching: ${next_steps.length}\n  ${branching_string}`);
  }

// terminal
  if(isSuccess) {
    console.log(clc.green(` âœ“ Target Term Reached!`));
  }
}

var path = [];
path.push({
  type: "step",
  step: {
    from: "",
    to: initial_id,
    rule: ""
  }
})

var state = "step"; // step, behaviour
const doStepState = (key) => {
  let id = path[path.length - 1].step.to;
  let steps = E[id];
  switch(key) {
    case "0":
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
      let index = parseInt(key) || 0;
      path.push({
        type: "branch",
        branch: index,
        step: steps[index]
      })
      break;
    case "n":
      if(steps && steps.length === 1) {
        path.push({
          type: "step",
          step: steps[0]
        });
      }
      break;
    case "N":
      while(steps && steps.length === 1) {
        path.push({
          type: "step",
          step: steps[0]
        })
        steps = E[steps[0].to];
      }
      // if(path.length > 0) {
      //   let cstep = path[path.length - 1];
      //   current_step = v.steps.length - 1;
      // }
      break;
    case "p":
      if(path.length > 1) {
        path.pop();
      }
      break;
    case "P":
      if(path.length > 1) {
        path.pop();
        current_step = getNode(path).steps.length - 1;
      } else {
        current_step = 0;
      }
      break;
    case "b":
      drawBehaviour();
      break;
    case "r":
    case "R":
      show_rule = !show_rule;
      break;
    case "C":
    case "c":
      show_constraint = !show_constraint;
      break;
    case "\u0003":
    case "q":
      process.exit();
      break;
    default:
      console.log("key: " + key);
  }

  draw(path);
}

clear();
// drawStep(current_element);
draw(path);

stdin.on( 'data', function (key) {
  clear();

  if(state === "step") {
    doStepState(key)
  } else if(state === "behaviour") {
    state = "step";
  }
})
