#!/usr/bin/env node

const fs            = require("fs");
const path          = require("path");
const marked        = require("marked");
const {docopt}      = require("docopt");
const clc           = require("cli-color");
const _             = require("lodash");
const kjson         = require("../lib/kjson.js");
const kast          = require("../lib/kast.js");
const Config        = require("../lib/config.js");
const {
  makePrelude,
  makeRules,
  makeRunScript,
  getActs,
  parseAct,
  buildAct
}                   = require("../lib/build.js");
const {
  read,
  testPath,
  revert,
  ensureDirs,
  warn
}                   = require("../lib/util.js");

const KLAB_OUT = process.env.KLAB_OUT || "out";

const usage = `
Usage:
  klab build [options]

Options:
  --spec=<spec>
  --filter=<filter>
  --trust
  --exact-gas
`
const cmd = docopt(usage, {
  argv: ["build"].concat(process.argv.slice(2))
});

if (!testPath("./config.json")) {revert("No config.json file in directory. Review `klab/examples` folder for inspiration")}
const config_json   = JSON.parse(fs.readFileSync("./config.json"));
const config        = Config(config_json);
const config_path   = cmd["--spec"] || config.src.specification;
const filter_subject= cmd["--filter"] || null;
const EXACT_GAS     = cmd["--exact-gas"] || false;

const raw_md_config = read(config_path)

ensureDirs([
  KLAB_OUT,
  path.join(KLAB_OUT, "specs"),
  path.join(KLAB_OUT, "acts"),
  path.join(KLAB_OUT, "gas")
]);

config.trusted = cmd["--trust"];

const acts_str_arr = getActs(raw_md_config);


// searches and adds abi variables with "ABI_" prefix

let act_collection = acts_str_arr
  .map(parseAct)

// * build tests cases
// * enrich with gas conditions
// act2name
const __a2n = act => act.subject + "_" + act.name;
const __hasGas = name => testPath(path.join(KLAB_OUT, "gas", name + ".kast"));
const __getGas = name => read(path.join(KLAB_OUT, "gas", name + ".kast"));
const __getGasRaw = name => JSON.parse(read(path.join(KLAB_OUT, "gas", name + ".raw.kast.json")));
const proof_collection = act_collection
  // split into pass and fail cases
  .map(act => [{
    act: {...act},
    name: __a2n(act) + "_pass",
    pass: true,
    oog: false
  }].concat("iff" in act ? [{
    act: {...act},
    pass: false,
    oog: false,
    name: __a2n(act) + "_fail"
  }] : [] ))
  .reduce((a, cs) => a.concat(cs), [])
  // enrich with gas statements
  .map(pf => {
    // TODO - default
    pf.act.hasGas = EXACT_GAS && __hasGas(pf.name);
    var gas = "3000000";
    if(EXACT_GAS && __hasGas(pf.name)) {
      pf.act.gas = __getGas(pf.name);
      pf.act.gas_raw = kast.format(__getGasRaw(pf.name), true);
      return [{...pf}, {...pf, oog: true, name: pf.name + "_oog"}]
    } else {
      pf.act.gas = gas;
      return [{...pf}]
    }
  })
  .reduce((a, cs) => a.concat(cs), [])

let act_proofs = proof_collection
  .map(buildAct(config))


// let acts = act_collection
//   .map(buildAct(config))
//   .reduce((a, cs) => a.concat(cs), [])

const dep_graph = {};

// Add the imported rules from the calls field
act_proofs.forEach(rule => {
  // XXX - rule.imports has two different semantics - resolve
  dep_graph[rule.hash] = [];
  rule.imports = rule.imports
    .map(name => {
    console.log('needs ' + name + ' => ' + rule.name)
    let deps = act_proofs
      .filter(rul => rul.name.slice(0,-5) == name);

    dep_graph[rule.hash] = dep_graph[rule.hash].concat(deps
      .map(dep_pf => dep_pf.hash));

    if (deps.length == 0) {
        warn(`Act "${name}" not found!`);
    }

    return deps
      .map(rule => rule.spec + '\n[trusted]\n')
      .join('')
  })
})

const out = act_proofs
  //For some reason, the above code generates a list of lists.
  //Below applies the multiplication of the monad
  .reduce((a, act_proof) => ({
    ...a,
    [act_proof.name]: {
      v2n: act_proof.v2n,
      act: act_proof.act,
      hash: act_proof.hash
    }
  }), {})
out.dep_graph = dep_graph;

act_proofs.forEach(rule => {
  let _rules      = [rule.spec].concat(rule.imports)
  let module      = kjson.renderModule(_rules, rule.name)
  let module_path = path.join(KLAB_OUT, "specs", `${rule.name}.k`)

  let old_module  = "";
  if(testPath(module_path)) old_module = read(module_path);
  if(old_module != module) {
    console.log("write " + module_path);
    fs.writeFileSync(module_path, module);
  }
})

fs.writeFileSync(path.join(KLAB_OUT, "out.json"), JSON.stringify(out, false, 2))
fs.writeFileSync(path.join(KLAB_OUT, "specs.manifest"), Object.keys(out).join("\n"))
makeRunScript();
// RULES
makeRules(config);
// prelude
makePrelude(config);
